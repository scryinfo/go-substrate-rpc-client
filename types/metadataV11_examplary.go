// Go Substrate RPC Client (GSRPC) provides APIs and types around Polkadot and any Substrate-based chain RPC calls
//
// Copyright 2019 Centrifuge GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

// Parsed from ExamplaryMetadataV11SubstrateString
var ExamplaryMetadataV11Substrate = &Metadata{MagicNumber: 0x6174656d, Version: 0xb, IsMetadataV4: false, AsMetadataV4: MetadataV4{Modules: []ModuleMetadataV4(nil)}, IsMetadataV7: false, AsMetadataV7: MetadataV7{Modules: []ModuleMetadataV7(nil)}, IsMetadataV8: false, AsMetadataV8: MetadataV8{Modules: []ModuleMetadataV8(nil)}, IsMetadataV9: false, AsMetadataV9: MetadataV9{Modules: []ModuleMetadataV8(nil)}, IsMetadataV10: false, AsMetadataV10: MetadataV10{Modules: []ModuleMetadataV10(nil)}, IsMetadataV11: true, AsMetadataV11: MetadataV11{MetadataV10: MetadataV10{Modules: []ModuleMetadataV10{ModuleMetadataV10{Name: "System", HasStorage: true, Storage: StorageMetadataV10{Prefix: "System", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "AccountInfo<T::Index, T::AccountData>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The full account information for a particular account ID."}}, StorageFunctionMetadataV10{Name: "ExtrinsicCount", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total extrinsics count for the current block."}}, StorageFunctionMetadataV10{Name: "AllExtrinsicsWeight", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Weight", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total weight for all extrinsics put together, for the current block."}}, StorageFunctionMetadataV10{Name: "AllExtrinsicsLen", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, StorageFunctionMetadataV10{Name: "BlockHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Map of block numbers to block hashes."}}, StorageFunctionMetadataV10{Name: "ExtrinsicData", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, StorageFunctionMetadataV10{Name: "Number", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current block number being processed. Set by `execute_block`."}}, StorageFunctionMetadataV10{Name: "ParentHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Hash of the previous block."}}, StorageFunctionMetadataV10{Name: "ExtrinsicsRoot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics root of the current block, also part of the block header."}}, StorageFunctionMetadataV10{Name: "Digest", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Digest of the current block, also part of the block header."}}, StorageFunctionMetadataV10{Name: "Events", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Events deposited for the current block."}}, StorageFunctionMetadataV10{Name: "EventCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of events in the `Events<T>` list."}}, StorageFunctionMetadataV10{Name: "EventTopics", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "fill_block", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_ratio", Type: "Perbill"}}, Documentation: []Text{" A dispatch that will fill the block weight up to the given ratio."}}, FunctionMetadataV4{Name: "remark", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark."}}, FunctionMetadataV4{Name: "set_heap_pages", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pages", Type: "u64"}}, Documentation: []Text{" Set the number of pages in the WebAssembly environment's heap."}}, FunctionMetadataV4{Name: "set_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code."}}, FunctionMetadataV4{Name: "set_code_without_checks", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code without doing any checks of the given `code`."}}, FunctionMetadataV4{Name: "set_changes_trie_config", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "changes_trie_config", Type: "Option<ChangesTrieConfiguration>"}}, Documentation: []Text{" Set the new changes trie configuration."}}, FunctionMetadataV4{Name: "set_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []Text{" Set some items of storage."}}, FunctionMetadataV4{Name: "kill_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "Vec<Key>"}}, Documentation: []Text{" Kill some items from storage."}}, FunctionMetadataV4{Name: "kill_prefix", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefix", Type: "Key"}}, Documentation: []Text{" Kill all storage items with a key that starts with the given prefix."}}, FunctionMetadataV4{Name: "suicide", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Kill the sending account, assuming there are no references outstanding and the composite", " data is equal to its default value."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "ExtrinsicSuccess", Args: []Type{"DispatchInfo"}, Documentation: []Text{" An extrinsic completed successfully."}}, EventMetadataV4{Name: "ExtrinsicFailed", Args: []Type{"DispatchError", "DispatchInfo"}, Documentation: []Text{" An extrinsic failed."}}, EventMetadataV4{Name: "CodeUpdated", Args: []Type(nil), Documentation: []Text{" `:code` was updated."}}, EventMetadataV4{Name: "NewAccount", Args: []Type{"AccountId"}, Documentation: []Text{" A new account was created."}}, EventMetadataV4{Name: "KilledAccount", Args: []Type{"AccountId"}, Documentation: []Text{" An account was reaped."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidSpecName", Documentation: []Text{" The name of specification does not match between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "SpecVersionNotAllowedToDecrease", Documentation: []Text{" The specification version is not allowed to decrease between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "ImplVersionNotAllowedToDecrease", Documentation: []Text{" The implementation version is not allowed to decrease between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "SpecOrImplVersionNeedToIncrease", Documentation: []Text{" The specification or the implementation version need to increase between the", " current runtime and the new runtime."}}, ErrorMetadataV8{Name: "FailedToExtractRuntimeVersion", Documentation: []Text{" Failed to extract the runtime version from the new runtime.", "", " Either calling `Core_version` or decoding `RuntimeVersion` failed."}}, ErrorMetadataV8{Name: "NonDefaultComposite", Documentation: []Text{" Suicide called when the account has non-default composite data."}}, ErrorMetadataV8{Name: "NonZeroRefCount", Documentation: []Text{" There is a non-zero reference count preventing the account from being purged."}}}}, ModuleMetadataV10{Name: "Utility", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Utility", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Multisigs", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "T::AccountId", Key2: "[u8; 32]", Value: "Multisig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of open multisig operations."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "batch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "calls", Type: "Vec<<T as Trait>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls.", "", " This will execute until the first one fails and then stop.", "", " May be called from any origin.", "", " - `calls`: The calls to be dispatched from the same origin.", "", " # <weight>", " - The sum of the weights of the `calls`.", " - One event.", " # </weight>", "", " This will return `Ok` in all circumstances. To determine the success of the batch, an", " event is deposited. If a call failed and the batch was interrupted, then the", " `BatchInterrupted` event is deposited, along with the number of successful calls made", " and the error of the failed call. If all were successful, then the `BatchCompleted`", " event is deposited."}}, FunctionMetadataV4{Name: "as_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "u16"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Send a call through an indexed pseudonym of the sender.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - The weight of the `call` + 10,000.", " # </weight>"}}, FunctionMetadataV4{Name: "as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " If there are enough, then dispatch the call.", "", " Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus", " `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call`: The call to be executed.", "", " NOTE: Unless this is the final approval, you will generally want to use", " `approve_as_multi` instead, since it only requires a hash of the call.", "", " Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise", " on success, result is `Ok` and the result from the interior call, if it was executed,", " may be found in the deposited `MultisigExecuted` event.", "", " # <weight>", " - `O(S + Z + Call)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - The weight of the `call`.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `MultisigDepositBase + threshold * MultisigDepositFactor`.", " # </weight>"}}, FunctionMetadataV4{Name: "approve_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus", " `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call_hash`: The hash of the call to be executed.", "", " NOTE: If this is the final approval, you will want to use `as_multi` instead.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `MultisigDepositBase + threshold * MultisigDepositFactor`.", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "timepoint", Type: "Timepoint<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}}, Documentation: []Text{" Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously", " for this operation will be unreserved on success.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `timepoint`: The timepoint (block number and transaction index) of the first approval", " transaction for this dispatch.", " - `call_hash`: The hash of the call to be executed.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - One event.", " - I/O: 1 read `O(S)`, one remove.", " - Storage: removes one item.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "BatchInterrupted", Args: []Type{"u32", "DispatchError"}, Documentation: []Text{" Batch of dispatches did not complete fully. Index of first failing dispatch given, as", " well as the error."}}, EventMetadataV4{Name: "BatchCompleted", Args: []Type(nil), Documentation: []Text{" Batch of dispatches completed fully with no error."}}, EventMetadataV4{Name: "NewMultisig", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A new multisig operation has begun. First param is the account that is approving,", " second is the multisig account."}}, EventMetadataV4{Name: "MultisigApproval", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId"}, Documentation: []Text{" A multisig operation has been approved by someone. First param is the account that is", " approving, third is the multisig account."}}, EventMetadataV4{Name: "MultisigExecuted", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "DispatchResult"}, Documentation: []Text{" A multisig operation has been executed. First param is the account that is", " approving, third is the multisig account."}}, EventMetadataV4{Name: "MultisigCancelled", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId"}, Documentation: []Text{" A multisig operation has been cancelled. First param is the account that is", " cancelling, third is the multisig account."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "ZeroThreshold", Documentation: []Text{" Threshold is too low (zero)."}}, ErrorMetadataV8{Name: "AlreadyApproved", Documentation: []Text{" Call is already approved by this signatory."}}, ErrorMetadataV8{Name: "NoApprovalsNeeded", Documentation: []Text{" Call doesn't need any (more) approvals."}}, ErrorMetadataV8{Name: "TooFewSignatories", Documentation: []Text{" There are too few signatories in the list."}}, ErrorMetadataV8{Name: "TooManySignatories", Documentation: []Text{" There are too many signatories in the list."}}, ErrorMetadataV8{Name: "SignatoriesOutOfOrder", Documentation: []Text{" The signatories were provided out of order; they should be ordered."}}, ErrorMetadataV8{Name: "SenderInSignatories", Documentation: []Text{" The sender was contained in the other signatories; it shouldn't be."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Multisig operation not found when attempting to cancel."}}, ErrorMetadataV8{Name: "NotOwner", Documentation: []Text{" Only the account that originally created the multisig is able to cancel it."}}, ErrorMetadataV8{Name: "NoTimepoint", Documentation: []Text{" No timepoint was given, yet the multisig operation is already underway."}}, ErrorMetadataV8{Name: "WrongTimepoint", Documentation: []Text{" A different timepoint was given to the multisig operation that is underway."}}, ErrorMetadataV8{Name: "UnexpectedTimepoint", Documentation: []Text{" A timepoint was given, yet no multisig operation is underway."}}}}, ModuleMetadataV10{Name: "Babe", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Babe", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "EpochIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current epoch index."}}, StorageFunctionMetadataV10{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current epoch authorities."}}, StorageFunctionMetadataV10{Name: "GenesisSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The slot at which the first epoch actually started. This is 0", " until the first block of the chain."}}, StorageFunctionMetadataV10{Name: "CurrentSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current slot number."}}, StorageFunctionMetadataV10{Name: "Randomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The epoch randomness for the *current* epoch.", "", " # Security", "", " This MUST NOT be used for gambling, as it can be influenced by a", " malicious validator in the short term. It MAY be used in many", " cryptographic protocols, however, so long as one remembers that this", " (like everything else on-chain) it is public. For example, it can be", " used where a number is needed that cannot have been chosen by an", " adversary, for purposes such as public-coin zero-knowledge proofs."}}, StorageFunctionMetadataV10{Name: "NextRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Next epoch randomness."}}, StorageFunctionMetadataV10{Name: "SegmentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Randomness under construction.", "", " We make a tradeoff between storage accesses and list length.", " We store the under-construction randomness in segments of up to", " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.", "", " Once a segment reaches this length, we begin the next one.", " We reset all segments and return to `0` at the beginning of every", " epoch."}}, StorageFunctionMetadataV10{Name: "UnderConstruction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "u32", Value: "Vec<[u8; 32]>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}, StorageFunctionMetadataV10{Name: "Initialized", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "MaybeVrf", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) which is `Some`", " if per-block initialization has already been called for current block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EpochDuration", Type: "u64", Value: Bytes{0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of **slots** that an epoch takes. We couple sessions to", " epochs, i.e. we start a new session once the new epoch begins."}}, ModuleConstantMetadataV6{Name: "ExpectedBlockTime", Type: "T::Moment", Value: Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The expected average block time at which BABE should be creating", " blocks. Since BABE is probabilistic it is not trivial to figure out", " what the expected average block time should be based on the slot", " duration and the security parameter `c` (where `1 - c` represents", " the probability of a slot being empty)."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Timestamp", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Timestamp", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Now", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current time for the current block."}}, StorageFunctionMetadataV10{Name: "DidUpdate", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "MinimumPeriod", Type: "T::Moment", Value: Bytes{0xdc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Authorship", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Authorship", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Uncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Uncles"}}, StorageFunctionMetadataV10{Name: "Author", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Author of current block."}}, StorageFunctionMetadataV10{Name: "DidSetUncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Whether uncles were already set in this block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_uncles", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_uncles", Type: "Vec<T::Header>"}}, Documentation: []Text{" Provide a set of uncles."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidUncleParent", Documentation: []Text{" The uncle parent not in the chain."}}, ErrorMetadataV8{Name: "UnclesAlreadySet", Documentation: []Text{" Uncles already set in the block."}}, ErrorMetadataV8{Name: "TooManyUncles", Documentation: []Text{" Too many uncles."}}, ErrorMetadataV8{Name: "GenesisUncle", Documentation: []Text{" The uncle is genesis."}}, ErrorMetadataV8{Name: "TooHighUncle", Documentation: []Text{" The uncle is too high in chain."}}, ErrorMetadataV8{Name: "UncleAlreadyIncluded", Documentation: []Text{" The uncle is already included."}}, ErrorMetadataV8{Name: "OldUncle", Documentation: []Text{" The uncle isn't recent enough to be included."}}}}, ModuleMetadataV10{Name: "Indices", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Indices", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Accounts", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountIndex", Value: "(T::AccountId, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The lookup from index to account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "claim", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an previously unassigned index.", "", " Payment: `Deposit` is reserved from the sender account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be claimed. This must not be in use.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an index already owned by the sender to another account. The balance reservation", " is effectively transferred to the new account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be re-assigned. This must be owned by the sender.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One transfer operation.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "free", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Free up an index owned by the sender.", "", " Payment: Any previous deposit placed for the index is unreserved in the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must own the index.", "", " - `index`: the index to be freed. This must be owned by the sender.", "", " Emits `IndexFreed` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Force an index to an account. This doesn't require a deposit. If the index is already", " held, then any deposit is reimbursed to its current owner.", "", " The dispatch origin for this call must be _Root_.", "", " - `index`: the index to be (re-)assigned.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - Up to one reserve operation.", " - One event.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IndexAssigned", Args: []Type{"AccountId", "AccountIndex"}, Documentation: []Text{" A account index was assigned."}}, EventMetadataV4{Name: "IndexFreed", Args: []Type{"AccountIndex"}, Documentation: []Text{" A account index has been freed up (unassigned)."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Balances", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Balances", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "TotalIssuance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total units issued in the system."}}, StorageFunctionMetadataV10{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "AccountData<T::Balance>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance of an account.", "", " NOTE: THIS MAY NEVER BE IN EXISTENCE AND YET HAVE A `total().is_zero()`. If the total", " is ever zero, then the entry *MUST* be removed.", "", " NOTE: This is only used in the case that this module is used to store balances."}}, StorageFunctionMetadataV10{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<BalanceLock<T::Balance>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any liquidity locks on some account balances.", " NOTE: Should only be accessed when setting, changing and freeing a lock."}}, StorageFunctionMetadataV10{Name: "IsUpgraded", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if network has been upgraded to this version.", "", " True for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config  See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.", "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional", "     check that the transfer will not kill the origin account.", "", " # </weight>"}}, FunctionMetadataV4{Name: "set_balance", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "new_free", Type: "Compact<T::Balance>"}, FunctionArgumentMetadata{Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`frame_system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified."}}, FunctionMetadataV4{Name: "transfer_keep_alive", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Same as the [`transfer`] call, but with a check that the transfer will not kill the", " origin account.", "", " 99% of the time you want [`transfer`] instead.", "", " [`transfer`]: struct.Module.html#method.transfer"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Endowed", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was created with some free balance."}}, EventMetadataV4{Name: "DustLost", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was removed whose balance was non-zero but below ExistentialDeposit,", " resulting in an outright loss."}}, EventMetadataV4{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer succeeded (from, to, value)."}}, EventMetadataV4{Name: "BalanceSet", Args: []Type{"AccountId", "Balance", "Balance"}, Documentation: []Text{" A balance was set by root (who, free, reserved)."}}, EventMetadataV4{Name: "Deposit", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some amount was deposited (e.g. for transaction fees)."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ExistentialDeposit", Type: "T::Balance", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to keep an account open."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "VestingBalance", Documentation: []Text{" Vesting balance too high to send value"}}, ErrorMetadataV8{Name: "LiquidityRestrictions", Documentation: []Text{" Account liquidity restrictions prevent withdrawal"}}, ErrorMetadataV8{Name: "Overflow", Documentation: []Text{" Got an overflow after adding"}}, ErrorMetadataV8{Name: "InsufficientBalance", Documentation: []Text{" Balance too low to send value"}}, ErrorMetadataV8{Name: "ExistentialDeposit", Documentation: []Text{" Value too low to create account due to existential deposit"}}, ErrorMetadataV8{Name: "KeepAlive", Documentation: []Text{" Transfer/payment would kill account"}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" A vesting schedule already exists for this account"}}, ErrorMetadataV8{Name: "DeadAccount", Documentation: []Text{" Beneficiary account must pre-exist"}}}}, ModuleMetadataV10{Name: "TransactionPayment", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Balances", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "NextFeeMultiplier", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Multiplier", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}}}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "TransactionBaseFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, ModuleConstantMetadataV6{Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Staking", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Staking", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "HistoryDepth", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x54, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of era to keep in history.", "", " Information is kept for eras in `[current_era - history_depth; current_era]", "", " Must be more than the number of era delayed by session otherwise.", " i.e. active era must always be in history.", " i.e. `active_era > current_era - history_depth` must be guaranteed."}}, StorageFunctionMetadataV10{Name: "ValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ideal number of staking participants."}}, StorageFunctionMetadataV10{Name: "MinimumValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x4, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum number of staking participants before emergency conditions are imposed."}}, StorageFunctionMetadataV10{Name: "Invulnerables", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any validators that may never be slashed or forcibly kicked. It's a Vec since they're", " easy to initialize and the performance hit is minimal (we expect no more than four", " invulnerables) and restricted to testnets."}}, StorageFunctionMetadataV10{Name: "Bonded", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all locked \"stash\" accounts to the controller account."}}, StorageFunctionMetadataV10{Name: "Ledger", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "StakingLedger<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."}}, StorageFunctionMetadataV10{Name: "Payee", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "RewardDestination", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Where the reward payment should be made. Keyed by stash."}}, StorageFunctionMetadataV10{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ValidatorPrefs", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from (wannabe) validator stash key to the preferences of that validator."}}, StorageFunctionMetadataV10{Name: "Nominators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Nominations<T::AccountId>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from nominator stash key to the set of stash keys of all validators to nominate."}}, StorageFunctionMetadataV10{Name: "CurrentEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current era index.", "", " This is the latest planned era, depending on how session module queues the validator", " set, it might be active or not."}}, StorageFunctionMetadataV10{Name: "ActiveEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ActiveEraInfo<MomentOf<T>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The active era information, it holds index and start.", "", " The active era is the era currently rewarded.", " Validator set of this era must be equal to `SessionInterface::validators`."}}, StorageFunctionMetadataV10{Name: "ErasStartSessionIndex", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The session index at which the era start for the last `HISTORY_DEPTH` eras"}}, StorageFunctionMetadataV10{Name: "ErasStakers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Exposure of validator at era.", "", " This is keyed first by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV10{Name: "ErasStakersClipped", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Clipped Exposure of validator at era.", "", " This is similar to [`ErasStakers`] but number of nominators exposed is reduce to the", " `T::MaxNominatorRewardedPerValidator` biggest stakers.", " This is used to limit the i/o cost for the nominator payout.", "", " This is keyed fist by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV10{Name: "ErasValidatorPrefs", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "EraIndex", Key2: "T::AccountId", Value: "ValidatorPrefs", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Similarly to `ErasStakers` this holds the preferences of validators.", "", " This is keyed fist by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras."}}, StorageFunctionMetadataV10{Name: "ErasValidatorReward", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The total validator era payout for the last `HISTORY_DEPTH` eras.", "", " Eras that haven't finished yet or has been removed doesn't have reward."}}, StorageFunctionMetadataV10{Name: "ErasRewardPoints", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "EraRewardPoints<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Rewards for the last `HISTORY_DEPTH` eras.", " If reward hasn't been set or has been removed then 0 reward is returned."}}, StorageFunctionMetadataV10{Name: "ErasTotalStake", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total amount staked for the last `HISTORY_DEPTH` eras.", " If total hasn't been set or has been removed then 0 stake is returned."}}, StorageFunctionMetadataV10{Name: "ForceEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Forcing", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the next session change will be a new era regardless of index."}}, StorageFunctionMetadataV10{Name: "SlashRewardFraction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Perbill", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The percentage of the slash that is distributed to reporters.", "", " The rest of the slashed value is handled by the `Slash`."}}, StorageFunctionMetadataV10{Name: "CanceledSlashPayout", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency given to reporters of a slash event which was", " canceled by extraordinary circumstances (e.g. governance)."}}, StorageFunctionMetadataV10{Name: "UnappliedSlashes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All unapplied slashes that are queued for later."}}, StorageFunctionMetadataV10{Name: "BondedEras", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(EraIndex, SessionIndex)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from still-bonded eras to the first session index of that era.", "", " Must contains information for eras for the range:", " `[active_era - bounding_duration; active_era]`"}}, StorageFunctionMetadataV10{Name: "ValidatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "(Perbill, BalanceOf<T>)", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: true, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on validators, mapped by era to the highest slash proportion", " and slash value of the era."}}, StorageFunctionMetadataV10{Name: "NominatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "BalanceOf<T>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: true, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on nominators, mapped by era to the highest slash value of the era."}}, StorageFunctionMetadataV10{Name: "SlashingSpans", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "slashing::SlashingSpans", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Slashing spans for stash accounts."}}, StorageFunctionMetadataV10{Name: "SpanSlash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(T::AccountId, slashing::SpanIndex)", Value: "slashing::SpanRecord<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Records information about the maximum slash of a stash within a slashing span,", " as well as how much reward has been paid out."}}, StorageFunctionMetadataV10{Name: "EarliestUnappliedSlash", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The earliest era for which we have a pending, unapplied slash."}}, StorageFunctionMetadataV10{Name: "IsUpgraded", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if network has been upgraded to this version.", "", " True for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" Take the origin account as a stash and lock up `value` of its balance. `controller` will", " be the account that controls it.", "", " `value` must be more than the `minimum_balance` specified by `T::Currency`.", "", " The dispatch origin for this call must be _Signed_ by the stash account.", "", " # <weight>", " - Independent of the arguments. Moderate complexity.", " - O(1).", " - Three extra DB entries.", "", " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless", " the `origin` falls below _existential deposit_ and gets removed as dust.", " # </weight>"}}, FunctionMetadataV4{Name: "bond_extra", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max_additional", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Add some extra amount that have appeared in the stash `free_balance` into the balance up", " for staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount", " that can be added.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - O(1).", " - One DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "unbond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::minimum_balance(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)", " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need", " to be called first to remove some of the chunks (if possible).", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::withdraw_unbonded`].", "", " # <weight>", " - Independent of the arguments. Limited but potentially exploitable complexity.", " - Contains a limited number of reads.", " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)", "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.", "   The only way to clean the aforementioned storage item is also user-controlled via", "   `withdraw_unbonded`.", " - One DB entry.", " </weight>"}}, FunctionMetadataV4{Name: "withdraw_unbonded", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::unbond`].", "", " # <weight>", " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.", "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is", "  indirectly user-controlled. See [`unbond`] for more detail.", " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, FunctionMetadataV4{Name: "validate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefs", Type: "ValidatorPrefs"}}, Documentation: []Text{" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, FunctionMetadataV4{Name: "nominate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "targets", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - The transaction's complexity is proportional to the size of `targets`,", " which is capped at `MAX_NOMINATIONS`.", " - Both the reads and writes follow a similar pattern.", " # </weight>"}}, FunctionMetadataV4{Name: "chill", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains one read.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, FunctionMetadataV4{Name: "set_payee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, FunctionMetadataV4{Name: "set_controller", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" (Re-)set the controller of a stash.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, FunctionMetadataV4{Name: "set_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "Compact<u32>"}}, Documentation: []Text{" The ideal number of validators."}}, FunctionMetadataV4{Name: "force_no_eras", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be no new eras indefinitely.", "", " # <weight>", " - No arguments.", " # </weight>"}}, FunctionMetadataV4{Name: "force_new_era", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of the next session. After this, it will be", " reset to normal (non-forced) behaviour.", "", " # <weight>", " - No arguments.", " # </weight>"}}, FunctionMetadataV4{Name: "set_invulnerables", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "validators", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the validators who cannot be slashed (if any)."}}, FunctionMetadataV4{Name: "force_unstake", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}}, Documentation: []Text{" Force a current staker to become completely unstaked, immediately."}}, FunctionMetadataV4{Name: "force_new_era_always", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of sessions indefinitely.", "", " # <weight>", " - One storage write", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_deferred_slash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "slash_indices", Type: "Vec<u32>"}}, Documentation: []Text{" Cancel enactment of a deferred slash. Can be called by either the root origin or", " the `T::SlashCancelOrigin`.", " passing the era and indices of the slashes for that era to kill.", "", " # <weight>", " - One storage write.", " # </weight>"}}, FunctionMetadataV4{Name: "payout_nominator", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "validators", Type: "Vec<(T::AccountId, u32)>"}}, Documentation: []Text{" Make one nominator's payout for one era.", "", " - `who` is the controller account of the nominator to pay out.", " - `era` may not be lower than one following the most recently paid era. If it is higher,", "   then it indicates an instruction to skip the payout of all previous eras.", " - `validators` is the list of all validators that `who` had exposure to during `era`.", "   If it is incomplete, then less than the full reward will be paid out.", "   It must not exceed `MAX_NOMINATIONS`.", "", " WARNING: once an era is payed for a validator such validator can't claim the payout of", " previous era.", "", " WARNING: Incorrect arguments here can result in loss of payout. Be very careful.", "", " # <weight>", " - Number of storage read of `O(validators)`; `validators` is the argument of the call,", "   and is bounded by `MAX_NOMINATIONS`.", " - Each storage read is `O(N)` size and decode complexity; `N` is the  maximum", "   nominations that can be given to a single validator.", " - Computation complexity: `O(MAX_NOMINATIONS * logN)`; `MAX_NOMINATIONS` is the", "   maximum number of validators that may be nominated by a single nominator, it is", "   bounded only economically (all nominators are required to place a minimum stake).", " # </weight>"}}, FunctionMetadataV4{Name: "payout_validator", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}}, Documentation: []Text{" Make one validator's payout for one era.", "", " - `who` is the controller account of the validator to pay out.", " - `era` may not be lower than one following the most recently paid era. If it is higher,", "   then it indicates an instruction to skip the payout of all previous eras.", "", " WARNING: once an era is payed for a validator such validator can't claim the payout of", " previous era.", "", " WARNING: Incorrect arguments here can result in loss of payout. Be very careful.", "", " # <weight>", " - Time complexity: O(1).", " - Contains a limited number of reads and writes.", " # </weight>"}}, FunctionMetadataV4{Name: "rebond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Rebond a portion of the stash scheduled to be unlocked.", "", " # <weight>", " - Time complexity: O(1). Bounded by `MAX_UNLOCKING_CHUNKS`.", " - Storage changes: Can't increase storage, only decrease it.", " # </weight>"}}, FunctionMetadataV4{Name: "set_history_depth", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_history_depth", Type: "Compact<EraIndex>"}}, Documentation: []Text{" Set history_depth value.", "", " Origin must be root."}}, FunctionMetadataV4{Name: "reap_stash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}}, Documentation: []Text{" Remove all data structure concerning a staker/stash once its balance is zero.", " This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone", " and the target `stash` must have no funds left.", "", " This can be called from any origin.", "", " - `stash`: The stash account to reap. Its balance must be zero."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Reward", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The staker has been rewarded by this amount. AccountId is controller account."}}, EventMetadataV4{Name: "Slash", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" One validator (and its nominators) has been slashed by the given amount."}}, EventMetadataV4{Name: "OldSlashingReportDiscarded", Args: []Type{"SessionIndex"}, Documentation: []Text{" An old slashing report from a prior era was discarded because it could", " not be processed."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "SessionsPerEra", Type: "SessionIndex", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of sessions per era."}}, ModuleConstantMetadataV6{Name: "BondingDuration", Type: "EraIndex", Value: Bytes{0xa0, 0x2, 0x0, 0x0}, Documentation: []Text{" Number of eras that staked funds must remain bonded for."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotController", Documentation: []Text{" Not a controller account."}}, ErrorMetadataV8{Name: "NotStash", Documentation: []Text{" Not a stash account."}}, ErrorMetadataV8{Name: "AlreadyBonded", Documentation: []Text{" Stash is already bonded."}}, ErrorMetadataV8{Name: "AlreadyPaired", Documentation: []Text{" Controller is already paired."}}, ErrorMetadataV8{Name: "EmptyTargets", Documentation: []Text{" Targets cannot be empty."}}, ErrorMetadataV8{Name: "DuplicateIndex", Documentation: []Text{" Duplicate index."}}, ErrorMetadataV8{Name: "InvalidSlashIndex", Documentation: []Text{" Slash record index out of bounds."}}, ErrorMetadataV8{Name: "InsufficientValue", Documentation: []Text{" Can not bond with value less than minimum balance."}}, ErrorMetadataV8{Name: "NoMoreChunks", Documentation: []Text{" Can not schedule more unlock chunks."}}, ErrorMetadataV8{Name: "NoUnlockChunk", Documentation: []Text{" Can not rebond without unlocking chunks."}}, ErrorMetadataV8{Name: "FundedTarget", Documentation: []Text{" Attempting to target a stash that still has funds."}}, ErrorMetadataV8{Name: "InvalidEraToReward", Documentation: []Text{" Invalid era to reward."}}, ErrorMetadataV8{Name: "InvalidNumberOfNominations", Documentation: []Text{" Invalid number of nominations."}}}}, ModuleMetadataV10{Name: "Session", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Session", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::ValidatorId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of validators."}}, StorageFunctionMetadataV10{Name: "CurrentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current index of the session."}}, StorageFunctionMetadataV10{Name: "QueuedChanged", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the underlying economic identities or weighting behind the validators", " has changed in the queued validator set."}}, StorageFunctionMetadataV10{Name: "QueuedKeys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::ValidatorId, T::Keys)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queued keys for the next session. When the next session begins, these keys", " will be used to determine the validator's session keys."}}, StorageFunctionMetadataV10{Name: "DisabledValidators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<u32>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Indices of disabled validators.", "", " The set is cleared when `on_session_ending` returns a new set of identities."}}, StorageFunctionMetadataV10{Name: "NextKeys", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "T::ValidatorId", Value: "T::Keys", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next session keys for a validator.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}, StorageFunctionMetadataV10{Name: "KeyOwner", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "(KeyTypeId, Vec<u8>)", Value: "T::ValidatorId", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The owner of a key. The second key is the `KeyTypeId` + the encoded key.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_keys", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "T::Keys"}, FunctionArgumentMetadata{Name: "proof", Type: "Vec<u8>"}}, Documentation: []Text{" Sets the session key(s) of the function caller to `keys`.", " Allows an account to set its session key prior to becoming a validator.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - O(log n) in number of accounts.", " - One extra DB entry.", " - Increases system account refs by one on success iff there were previously no keys set.", "   In this case, purge_keys will need to be called before the account can be removed.", " # </weight>"}}, FunctionMetadataV4{Name: "purge_keys", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Removes any session key(s) of the function caller.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - O(N) in number of key ", " - Removes N + 1 DB entries.", " - Reduces system account refs by one on success.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewSession", Args: []Type{"SessionIndex"}, Documentation: []Text{" New session has happened. Note that the argument is the session index, not the block", " number as the type might suggest."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "DEDUP_KEY_PREFIX", Type: "&[u8]", Value: Bytes{0x34, 0x3a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x6b, 0x65, 0x79, 0x73}, Documentation: []Text{" Used as first key for `NextKeys` and `KeyOwner` to put all the data into the same branch", " of the trie."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidProof", Documentation: []Text{" Invalid ownership proof."}}, ErrorMetadataV8{Name: "NoAssociatedValidatorId", Documentation: []Text{" No associated validator ID for account."}}, ErrorMetadataV8{Name: "DuplicatedKey", Documentation: []Text{" Registered duplicate key."}}, ErrorMetadataV8{Name: "NoKeys", Documentation: []Text{" No keys are associated with this account."}}}}, ModuleMetadataV10{Name: "Democracy", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Democracy", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "PublicPropCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "PropIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of (public) proposals that have been made so far."}}, StorageFunctionMetadataV10{Name: "PublicProps", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(PropIndex, T::Hash, T::AccountId)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The public proposals. Unsorted. The second item is the proposal's hash."}}, StorageFunctionMetadataV10{Name: "Preimages", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "(Vec<u8>, T::AccountId, BalanceOf<T>, T::BlockNumber)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map of hashes to the proposal preimage, along with who registered it and their deposit.", " The block number is the block at which it was deposited."}}, StorageFunctionMetadataV10{Name: "DepositOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "PropIndex", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Those who have locked a deposit."}}, StorageFunctionMetadataV10{Name: "ReferendumCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free referendum index, aka the number of referenda started so far."}}, StorageFunctionMetadataV10{Name: "LowestUnbaked", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The lowest referendum index representing an unbaked referendum. Equal to", " `ReferendumCount` if there isn't a unbaked referendum."}}, StorageFunctionMetadataV10{Name: "ReferendumInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "ReferendumInfo<T::BlockNumber, T::Hash>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information concerning any given referendum."}}, StorageFunctionMetadataV10{Name: "DispatchQueue", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::BlockNumber, T::Hash, ReferendumIndex)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Queue of successful referenda to be dispatched. Stored ordered by block number."}}, StorageFunctionMetadataV10{Name: "VotersFor", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "Vec<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the voters for the current proposal."}}, StorageFunctionMetadataV10{Name: "VoteOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(ReferendumIndex, T::AccountId)", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the vote in a given referendum of a particular voter. The result is meaningful only", " if `voters_for` includes the voter when called with the referendum (you'll get the", " default `Vote` value otherwise). If you don't want to check `voters_for`, then you can", " also check for simple existence with `VoteOf::contains_key` first."}}, StorageFunctionMetadataV10{Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ProxyState<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Who is able to vote for whom. Value is the fund-holding account, key is the", " vote-transaction-sending account."}}, StorageFunctionMetadataV10{Name: "Delegations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(T::AccountId, Conviction)", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Get the account (and lock periods) to which another account is delegating vote."}}, StorageFunctionMetadataV10{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::BlockNumber", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Accounts for which there are locks in action which may be removed at some point in the", " future. The value is the block number at which the lock expires and may be removed."}}, StorageFunctionMetadataV10{Name: "LastTabledWasExternal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the last referendum tabled was submitted externally. False if it was a public", " proposal."}}, StorageFunctionMetadataV10{Name: "NextExternal", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "(T::Hash, VoteThreshold)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The referendum to be tabled whenever it would be valid to table an external proposal.", " This happens when a referendum needs to be tabled and one of two conditions are met:", " - `LastTabledWasExternal` is `false`; or", " - `PublicProps` is empty."}}, StorageFunctionMetadataV10{Name: "Blacklist", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "(T::BlockNumber, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A record of who vetoed what. Maps proposal hash to a possible existent block number", " (until when it may not be resubmitted) and who vetoed it."}}, StorageFunctionMetadataV10{Name: "Cancellations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Record of all proposals that have been subject to emergency cancellation."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - Two DB changes, one DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "second", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Compact<PropIndex>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - One DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, FunctionArgumentMetadata{Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "proxy_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, FunctionArgumentMetadata{Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact", " the proposal; otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "emergency_cancel", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "ReferendumIndex"}}, Documentation: []Text{" Schedule an emergency cancellation of a referendum. Cannot happen twice to the same", " referendum."}}, FunctionMetadataV4{Name: "external_propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a referendum to be tabled once it is legal to schedule an external", " referendum."}}, FunctionMetadataV4{Name: "external_propose_majority", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a majority-carries referendum to be tabled next once it is legal to schedule", " an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, FunctionMetadataV4{Name: "external_propose_default", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a negative-turnout-bias referendum to be tabled next once it is legal to", " schedule an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, FunctionMetadataV4{Name: "fast_track", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "voting_period", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Schedule the currently externally-proposed majority-carries referendum to be tabled", " immediately. If there is no externally-proposed referendum currently, or if there is one", " but it is not a majority-carries referendum then it fails.", "", " - `proposal_hash`: The hash of the current external proposal.", " - `voting_period`: The period that is allowed for voting on this proposal. Increased to", "   `EmergencyVotingPeriod` if too low.", " - `delay`: The number of block after voting has ended in approval and this should be", "   enacted. This doesn't have a minimum amount."}}, FunctionMetadataV4{Name: "veto_external", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Veto and blacklist the external proposal hash."}}, FunctionMetadataV4{Name: "cancel_referendum", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Remove a referendum."}}, FunctionMetadataV4{Name: "cancel_queued", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "which", Type: "ReferendumIndex"}}, Documentation: []Text{" Cancel a proposal queued for enactment."}}, FunctionMetadataV4{Name: "activate_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Specify a proxy that is already open to us. Called by the stash.", "", " NOTE: Used to be called `set_proxy`.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "close_proxy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear the proxy. Called by the proxy.", "", " NOTE: Used to be called `resign_proxy`.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, FunctionMetadataV4{Name: "deactivate_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Deactivate the proxy, but leave open to this account. Called by the stash.", "", " The proxy must already be active.", "", " NOTE: Used to be called `remove_proxy`.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, FunctionMetadataV4{Name: "delegate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "to", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "conviction", Type: "Conviction"}}, Documentation: []Text{" Delegate vote.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "undelegate", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Undelegate vote.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "clear_public_proposals", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Veto and blacklist the proposal hash. Must be from Root origin."}}, FunctionMetadataV4{Name: "note_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This doesn't require the proposal to be", " in the dispatch queue but does require a deposit, returned once enacted."}}, FunctionMetadataV4{Name: "note_imminent_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This requires the proposal to be", " in the dispatch queue. No deposit is needed."}}, FunctionMetadataV4{Name: "reap_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Remove an expired proposal preimage and collect the deposit.", "", " This will only work after `VotingPeriod` blocks from the time that the preimage was", " noted, if it's the same account doing it. If it's a different account, then it'll only", " work an additional `EnactmentPeriod` later."}}, FunctionMetadataV4{Name: "unlock", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}}, Documentation: []Text(nil)}, FunctionMetadataV4{Name: "open_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}}, Documentation: []Text{" Become a proxy.", "", " This must be called prior to a later `activate_proxy`.", "", " Origin must be a Signed.", "", " - `target`: The account whose votes will later be proxied.", "", " `close_proxy` must be called before the account can be destroyed.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"PropIndex", "Balance"}, Documentation: []Text{" A motion has been proposed by a public account."}}, EventMetadataV4{Name: "Tabled", Args: []Type{"PropIndex", "Balance", "Vec<AccountId>"}, Documentation: []Text{" A public proposal has been tabled for referendum vote."}}, EventMetadataV4{Name: "ExternalTabled", Args: []Type(nil), Documentation: []Text{" An external proposal has been tabled."}}, EventMetadataV4{Name: "Started", Args: []Type{"ReferendumIndex", "VoteThreshold"}, Documentation: []Text{" A referendum has begun."}}, EventMetadataV4{Name: "Passed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been approved by referendum."}}, EventMetadataV4{Name: "NotPassed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been rejected by referendum."}}, EventMetadataV4{Name: "Cancelled", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A referendum has been cancelled."}}, EventMetadataV4{Name: "Executed", Args: []Type{"ReferendumIndex", "bool"}, Documentation: []Text{" A proposal has been enacted."}}, EventMetadataV4{Name: "Delegated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" An account has delegated their vote to another account."}}, EventMetadataV4{Name: "Undelegated", Args: []Type{"AccountId"}, Documentation: []Text{" An account has cancelled a previous delegation operation."}}, EventMetadataV4{Name: "Vetoed", Args: []Type{"AccountId", "Hash", "BlockNumber"}, Documentation: []Text{" An external proposal has been vetoed."}}, EventMetadataV4{Name: "PreimageNoted", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal's preimage was noted, and the deposit taken."}}, EventMetadataV4{Name: "PreimageUsed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal preimage was removed and used (the deposit was returned)."}}, EventMetadataV4{Name: "PreimageInvalid", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was invalid."}}, EventMetadataV4{Name: "PreimageMissing", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was missing."}}, EventMetadataV4{Name: "PreimageReaped", Args: []Type{"Hash", "AccountId", "Balance", "AccountId"}, Documentation: []Text{" A registered preimage was removed and the deposit collected by the reaper (last item)."}}, EventMetadataV4{Name: "Unlocked", Args: []Type{"AccountId"}, Documentation: []Text{" An account has been unlocked successfully."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EnactmentPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The minimum period of locking and the period between a proposal being approved and enacted.", "", " It should generally be a little more than the unstake period to ensure that", " voting stakers have an opportunity to remove themselves from the system in the case where", " they are on the losing side of a vote."}}, ModuleConstantMetadataV6{Name: "LaunchPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) new public referenda are launched."}}, ModuleConstantMetadataV6{Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes."}}, ModuleConstantMetadataV6{Name: "MinimumDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be used as a deposit for a public referendum proposal."}}, ModuleConstantMetadataV6{Name: "EmergencyVotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x51, 0x1, 0x0}, Documentation: []Text{" Minimum voting period allowed for an emergency referendum."}}, ModuleConstantMetadataV6{Name: "CooloffPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" Period in blocks where an external proposal may not be re-submitted after being vetoed."}}, ModuleConstantMetadataV6{Name: "PreimageByteDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance that must be deposited per byte of preimage stored."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "ValueLow", Documentation: []Text{" Value too low"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal does not exist"}}, ErrorMetadataV8{Name: "NotProxy", Documentation: []Text{" Not a proxy"}}, ErrorMetadataV8{Name: "BadIndex", Documentation: []Text{" Unknown index"}}, ErrorMetadataV8{Name: "AlreadyCanceled", Documentation: []Text{" Cannot cancel the same proposal twice"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Proposal already made"}}, ErrorMetadataV8{Name: "ProposalBlacklisted", Documentation: []Text{" Proposal still blacklisted"}}, ErrorMetadataV8{Name: "NotSimpleMajority", Documentation: []Text{" Next external proposal not simple majority"}}, ErrorMetadataV8{Name: "InvalidHash", Documentation: []Text{" Invalid hash"}}, ErrorMetadataV8{Name: "NoProposal", Documentation: []Text{" No external proposal"}}, ErrorMetadataV8{Name: "AlreadyVetoed", Documentation: []Text{" Identity may not veto a proposal twice"}}, ErrorMetadataV8{Name: "AlreadyProxy", Documentation: []Text{" Already a proxy"}}, ErrorMetadataV8{Name: "WrongProxy", Documentation: []Text{" Wrong proxy"}}, ErrorMetadataV8{Name: "NotDelegated", Documentation: []Text{" Not delegated"}}, ErrorMetadataV8{Name: "DuplicatePreimage", Documentation: []Text{" Preimage already noted"}}, ErrorMetadataV8{Name: "NotImminent", Documentation: []Text{" Not imminent"}}, ErrorMetadataV8{Name: "Early", Documentation: []Text{" Too early"}}, ErrorMetadataV8{Name: "Imminent", Documentation: []Text{" Imminent"}}, ErrorMetadataV8{Name: "PreimageMissing", Documentation: []Text{" Preimage not found"}}, ErrorMetadataV8{Name: "ReferendumInvalid", Documentation: []Text{" Vote given for invalid referendum"}}, ErrorMetadataV8{Name: "PreimageInvalid", Documentation: []Text{" Invalid preimage"}}, ErrorMetadataV8{Name: "NoneWaiting", Documentation: []Text{" No proposals waiting"}}, ErrorMetadataV8{Name: "NotLocked", Documentation: []Text{" The target account does not have a lock."}}, ErrorMetadataV8{Name: "NotExpired", Documentation: []Text{" The lock on the account to be unlocked has not yet expired."}}, ErrorMetadataV8{Name: "NotOpen", Documentation: []Text{" A proxy-pairing was attempted to an account that was not open."}}, ErrorMetadataV8{Name: "WrongOpen", Documentation: []Text{" A proxy-pairing was attempted to an account that was open to another account."}}, ErrorMetadataV8{Name: "NotActive", Documentation: []Text{" A proxy-de-pairing was attempted to an account that was not active."}}}}, ModuleMetadataV10{Name: "Council", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance1Collective", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV10{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV10{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}}}, ModuleMetadataV10{Name: "TechnicalCommittee", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance2Collective", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV10{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV10{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}}}, ModuleMetadataV10{Name: "Elections", HasStorage: true, Storage: StorageMetadataV10{Prefix: "PhragmenElection", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current elected membership. Sorted based on account id."}}, StorageFunctionMetadataV10{Name: "RunnersUp", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current runners_up. Sorted based on low to high merit (worse to best runner)."}}, StorageFunctionMetadataV10{Name: "ElectionRounds", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total number of vote rounds that have happened, excluding the upcoming one."}}, StorageFunctionMetadataV10{Name: "VotesOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<T::AccountId>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes of a particular voter, with the round index of the votes."}}, StorageFunctionMetadataV10{Name: "StakeOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Locked stake of a voter."}}, StorageFunctionMetadataV10{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present candidate list. Sorted based on account-id. A current member or a runner can", " never enter this vector and is always implicitly assumed to be a candidate."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "votes", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Vote for a set of candidates for the upcoming round of election.", "", " The `votes` should:", "   - not be empty.", "   - be less than the number of candidates.", "", " Upon voting, `value` units of `who`'s balance is locked and a bond amount is reserved.", " It is the responsibility of the caller to not place all of their balance into the lock", " and keep some for further transactions.", "", " # <weight>", " #### State", " Reads: O(1)", " Writes: O(V) given `V` votes. V is bounded by 16.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_voter", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove `origin` as a voter. This removes the lock and returns the bond.", "", " # <weight>", " #### State", " Reads: O(1)", " Writes: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "report_defunct_voter", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Report `target` for being an defunct voter. In case of a valid report, the reporter is", " rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and", " their bond is slashed.", "", " A defunct voter is defined to be:", "   - a voter whose current submitted votes are all invalid. i.e. all of them are no", "     longer a candidate nor an active member.", "", " # <weight>", " #### State", " Reads: O(NLogM) given M current candidates and N votes for `target`.", " Writes: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "submit_candidacy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Submit oneself for candidacy.", "", " A candidate will either:", "   - Lose at the end of the term and forfeit their deposit.", "   - Win and become a member. Members will eventually get their stash back.", "   - Become a runner-up. Runners-ups are reserved members in case one gets forcefully", "     removed.", "", " # <weight>", " #### State", " Reads: O(LogN) Given N candidates.", " Writes: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "renounce_candidacy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Renounce one's intention to be a candidate for the next election round. 3 potential", " outcomes exist:", " - `origin` is a candidate and not elected in any set. In this case, the bond is", "   unreserved, returned and origin is removed as a candidate.", " - `origin` is a current runner up. In this case, the bond is unreserved, returned and", "   origin is removed as a runner.", " - `origin` is a current member. In this case, the bond is unreserved and origin is", "   removed as a member, consequently not being a candidate for the next round anymore.", "   Similar to [`remove_voter`], if replacement runners exists, they are immediately used."}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove a particular member from the set. This is effective immediately and the bond of", " the outgoing member is slashed.", "", " If a runner-up is available, then the best runner-up will be removed and replaces the", " outgoing member. Otherwise, a new phragmen round is started.", "", " Note that this does not affect the designated block number of the next election.", "", " # <weight>", " #### State", " Reads: O(do_phragmen)", " Writes: O(do_phragmen)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewTerm", Args: []Type{"Vec<(AccountId, Balance)>"}, Documentation: []Text{" A new term with new members. This indicates that enough candidates existed, not that", " enough have has been elected. The inner value must be examined for this purpose."}}, EventMetadataV4{Name: "EmptyTerm", Args: []Type(nil), Documentation: []Text{" No (or not enough) candidates existed for this round."}}, EventMetadataV4{Name: "MemberKicked", Args: []Type{"AccountId"}, Documentation: []Text{" A member has been removed. This should always be followed by either `NewTerm` ot", " `EmptyTerm`."}}, EventMetadataV4{Name: "MemberRenounced", Args: []Type{"AccountId"}, Documentation: []Text{" A member has renounced their candidacy."}}, EventMetadataV4{Name: "VoterReported", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A voter (first element) was reported (byt the second element) with the the report being", " successful or not (third element)."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "CandidacyBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "VotingBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "DesiredMembers", Type: "u32", Value: Bytes{0xd, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "DesiredRunnersUp", Type: "u32", Value: Bytes{0x7, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "TermDuration", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text(nil)}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "UnableToVote", Documentation: []Text{" Cannot vote when no candidates or members exist."}}, ErrorMetadataV8{Name: "NoVotes", Documentation: []Text{" Must vote for at least one candidate."}}, ErrorMetadataV8{Name: "TooManyVotes", Documentation: []Text{" Cannot vote more than candidates."}}, ErrorMetadataV8{Name: "MaximumVotesExceeded", Documentation: []Text{" Cannot vote more than maximum allowed."}}, ErrorMetadataV8{Name: "LowBalance", Documentation: []Text{" Cannot vote with stake less than minimum balance."}}, ErrorMetadataV8{Name: "UnableToPayBond", Documentation: []Text{" Voter can not pay voting bond."}}, ErrorMetadataV8{Name: "MustBeVoter", Documentation: []Text{" Must be a voter."}}, ErrorMetadataV8{Name: "ReportSelf", Documentation: []Text{" Cannot report self."}}, ErrorMetadataV8{Name: "DuplicatedCandidate", Documentation: []Text{" Duplicated candidate submission."}}, ErrorMetadataV8{Name: "MemberSubmit", Documentation: []Text{" Member cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "RunnerSubmit", Documentation: []Text{" Runner cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "InsufficientCandidateFunds", Documentation: []Text{" Candidate does not have enough funds."}}, ErrorMetadataV8{Name: "InvalidOrigin", Documentation: []Text{" Origin is not a candidate, member or a runner up."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Not a member."}}}}, ModuleMetadataV10{Name: "TechnicalMembership", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance1Membership", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current membership, stored as an ordered Vec."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Add a member `who` to the set.", "", " May only be called from `AddOrigin` or root."}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Remove a member `who` from the set.", "", " May only be called from `RemoveOrigin` or root."}}, FunctionMetadataV4{Name: "swap_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "remove", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "add", Type: "T::AccountId"}}, Documentation: []Text{" Swap out one member `remove` for another `add`.", "", " May only be called from `SwapOrigin` or root."}}, FunctionMetadataV4{Name: "reset_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Change the membership to a new set, disregarding the existing membership. Be nice and", " pass `members` pre-sorted.", "", " May only be called from `ResetOrigin` or root."}}, FunctionMetadataV4{Name: "change_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Swap out the sending member for some other key `new`.", "", " May only be called from `Signed` origin of a current member."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "MemberAdded", Args: []Type(nil), Documentation: []Text{" The given member was added; see the transaction for who."}}, EventMetadataV4{Name: "MemberRemoved", Args: []Type(nil), Documentation: []Text{" The given member was removed; see the transaction for who."}}, EventMetadataV4{Name: "MembersSwapped", Args: []Type(nil), Documentation: []Text{" Two members were swapped; see the transaction for who."}}, EventMetadataV4{Name: "MembersReset", Args: []Type(nil), Documentation: []Text{" The membership was reset; see the transaction for who the new set is."}}, EventMetadataV4{Name: "KeyChanged", Args: []Type(nil), Documentation: []Text{" One of the members' keys changed."}}, EventMetadataV4{Name: "Dummy", Args: []Type{"sp_std::marker::PhantomData<(AccountId, Event)>"}, Documentation: []Text{" Phantom member, never used."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "FinalityTracker", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "final_hint", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hint", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Hint that the author of this block thinks the best finalized", " block is the given number."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "WindowSize", Type: "T::BlockNumber", Value: Bytes{0x65, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of recent samples to keep from this chain. Default is 101."}}, ModuleConstantMetadataV6{Name: "ReportLatency", Type: "T::BlockNumber", Value: Bytes{0xe8, 0x3, 0x0, 0x0}, Documentation: []Text{" The delay after which point things become suspicious. Default is 1000."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "AlreadyUpdated", Documentation: []Text{" Final hint must be updated only once in the block"}}, ErrorMetadataV8{Name: "BadHint", Documentation: []Text{" Finalized height above block number"}}}}, ModuleMetadataV10{Name: "Grandpa", HasStorage: true, Storage: StorageMetadataV10{Prefix: "GrandpaFinality", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "AuthorityList", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" DEPRECATED", "", " This used to store the current authority set, which has been migrated to the well-known", " GRANDPA_AUTHORITIES_KEY unhashed key."}}, StorageFunctionMetadataV10{Name: "State", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" State of the current authority set."}}, StorageFunctionMetadataV10{Name: "PendingChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending change: (signaled at, scheduled change)."}}, StorageFunctionMetadataV10{Name: "NextForced", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" next block number where we can force a change."}}, StorageFunctionMetadataV10{Name: "Stalled", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" `true` if we are currently stalled."}}, StorageFunctionMetadataV10{Name: "CurrentSetId", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "SetId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, StorageFunctionMetadataV10{Name: "SetIdSession", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its members were responsible."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_misbehavior", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_report", Type: "Vec<u8>"}}, Documentation: []Text{" Report some misbehavior."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewAuthorities", Args: []Type{"AuthorityList"}, Documentation: []Text{" New authority set has been applied."}}, EventMetadataV4{Name: "Paused", Args: []Type(nil), Documentation: []Text{" Current authority set has been paused."}}, EventMetadataV4{Name: "Resumed", Args: []Type(nil), Documentation: []Text{" Current authority set has been resumed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "PauseFailed", Documentation: []Text{" Attempt to signal GRANDPA pause when the authority set isn't live", " (either paused or already pending pause)."}}, ErrorMetadataV8{Name: "ResumeFailed", Documentation: []Text{" Attempt to signal GRANDPA resume when the authority set isn't paused", " (either live or already pending resume)."}}, ErrorMetadataV8{Name: "ChangePending", Documentation: []Text{" Attempt to signal GRANDPA change with one already pending."}}, ErrorMetadataV8{Name: "TooSoon", Documentation: []Text{" Cannot signal forced change so soon after last."}}}}, ModuleMetadataV10{Name: "Treasury", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Treasury", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ProposalIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of proposals that have been made."}}, StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ProposalIndex", Value: "Proposal<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposals that have been made."}}, StorageFunctionMetadataV10{Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<ProposalIndex>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposal indices that have been approved but not yet awarded."}}, StorageFunctionMetadataV10{Name: "Tips", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "T::Hash", Value: "OpenTip<T::AccountId, BalanceOf<T>, T::BlockNumber, T::Hash>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Tips that are not yet completed. Keyed by the hash of `(reason, who)` from the value.", " This has the insecure enumerable hash function since the key itself is already", " guaranteed to be a secure hash."}}, StorageFunctionMetadataV10{Name: "Reasons", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "T::Hash", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Simple preimage lookup from the reason's hash to the original data. Again, has an", " insecure enumerable hash since the key is guaranteed to be the result of a secure hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose_spend", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change, one extra DB entry.", " # </weight>"}}, FunctionMetadataV4{Name: "reject_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Reject a proposed spend. The original deposit will be slashed.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB clear.", " # </weight>"}}, FunctionMetadataV4{Name: "approve_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, FunctionMetadataV4{Name: "report_awesome", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Report something `reason` that deserves a tip and claim any eventual the finder's fee.", "", " The dispatch origin for this call must be _Signed_.", "", " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as", " `TipReportDepositPerByte` for each byte in `reason`.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - `O(R)` where `R` length of `reason`.", " - One balance operation.", " - One storage mutation (codec `O(R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "retract_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.", "", " If successful, the original deposit will be unreserved.", "", " The dispatch origin for this call must be _Signed_ and the tip identified by `hash`", " must have been reported by the signing account through `report_awesome` (and not", " through `tip_new`).", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " Emits `TipRetracted` if successful.", "", " # <weight>", " - `O(T)`", " - One balance operation.", " - Two storage removals (one read, codec `O(T)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "tip_new", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "tip_value", Type: "BalanceOf<T>"}}, Documentation: []Text{" Give a tip for something new; no finder's fee will be taken.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers. `T` is", "   naturally capped as a membership set, `R` is limited through transaction-size.", " - Two storage insertions (codecs `O(R)`, `O(T)`), one read `O(1)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "tip_value", Type: "BalanceOf<T>"}}, Documentation: []Text{" Declare a tip value for an already-open tip.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary", "   account ID.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `TipClosing` if the threshold of tippers has been reached and the countdown period", " has started.", "", " # <weight>", " - `O(T)`", " - One storage mutation (codec `O(T)`), one storage read `O(1)`.", " - Up to one event.", " # </weight>"}}, FunctionMetadataV4{Name: "close_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Close and payout a tip.", "", " The dispatch origin for this call must be _Signed_.", "", " The tip identified by `hash` must have finished its countdown period.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " # <weight>", " - `O(T)`", " - One storage retrieval (codec `O(T)`) and two removals.", " - Up to three balance operations.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"ProposalIndex"}, Documentation: []Text{" New proposal."}}, EventMetadataV4{Name: "Spending", Args: []Type{"Balance"}, Documentation: []Text{" We have ended a spend period and will now allocate funds."}}, EventMetadataV4{Name: "Awarded", Args: []Type{"ProposalIndex", "Balance", "AccountId"}, Documentation: []Text{" Some funds have been allocated."}}, EventMetadataV4{Name: "Rejected", Args: []Type{"ProposalIndex", "Balance"}, Documentation: []Text{" A proposal was rejected; funds were slashed."}}, EventMetadataV4{Name: "Burnt", Args: []Type{"Balance"}, Documentation: []Text{" Some of our funds have been burnt."}}, EventMetadataV4{Name: "Rollover", Args: []Type{"Balance"}, Documentation: []Text{" Spending has finished; this is the amount that rolls over until next spend."}}, EventMetadataV4{Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds have been deposited."}}, EventMetadataV4{Name: "NewTip", Args: []Type{"Hash"}, Documentation: []Text{" A new tip suggestion has been opened."}}, EventMetadataV4{Name: "TipClosing", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has reached threshold and is closing."}}, EventMetadataV4{Name: "TipClosed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A tip suggestion has been closed."}}, EventMetadataV4{Name: "TipRetracted", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has been retracted."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ProposalBond", Type: "Permill", Value: Bytes{0x50, 0xc3, 0x0, 0x0}, Documentation: []Text{" Fraction of a proposal's value that should be bonded in order to place the proposal.", " An accepted proposal gets these back. A rejected proposal does not."}}, ModuleConstantMetadataV6{Name: "ProposalBondMinimum", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum amount of funds that should be placed in a deposit for making a proposal."}}, ModuleConstantMetadataV6{Name: "SpendPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" Period between successive spends."}}, ModuleConstantMetadataV6{Name: "Burn", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of spare funds (if any) that are burnt per spend period."}}, ModuleConstantMetadataV6{Name: "TipCountdown", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" The period for which a tip remains open after is has achieved threshold tippers."}}, ModuleConstantMetadataV6{Name: "TipFindersFee", Type: "Percent", Value: Bytes{0x14}, Documentation: []Text{" The amount of the final tip which goes to the original reporter of the tip."}}, ModuleConstantMetadataV6{Name: "TipReportDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for placing a tip report."}}, ModuleConstantMetadataV6{Name: "TipReportDepositPerByte", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per byte within the tip report reason."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InsufficientProposersBalance", Documentation: []Text{" Proposer's balance is too low."}}, ErrorMetadataV8{Name: "InvalidProposalIndex", Documentation: []Text{" No proposal at that index."}}, ErrorMetadataV8{Name: "ReasonTooBig", Documentation: []Text{" The reason given is just too big."}}, ErrorMetadataV8{Name: "AlreadyKnown", Documentation: []Text{" The tip was already found/started."}}, ErrorMetadataV8{Name: "UnknownTip", Documentation: []Text{" The tip hash is unknown."}}, ErrorMetadataV8{Name: "NotFinder", Documentation: []Text{" The account attempting to retract the tip is not the finder of the tip."}}, ErrorMetadataV8{Name: "StillOpen", Documentation: []Text{" The tip cannot be claimed/closed because there are not enough tippers yet."}}, ErrorMetadataV8{Name: "Premature", Documentation: []Text{" The tip cannot be claimed/closed because it's still in the countdown period."}}}}, ModuleMetadataV10{Name: "Contracts", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Contract", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "GasSpent", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Gas", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Gas spent so far in this block."}}, StorageFunctionMetadataV10{Name: "CurrentSchedule", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Schedule", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" Current cost schedule for contracts."}}, StorageFunctionMetadataV10{Name: "PristineCode", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from an original code hash to the original code, untouched by instrumentation."}}, StorageFunctionMetadataV10{Name: "CodeStorage", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "wasm::PrefabWasmModule", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping between an original code hash and instrumented wasm code, ready for execution."}}, StorageFunctionMetadataV10{Name: "AccountCounter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The subtrie counter."}}, StorageFunctionMetadataV10{Name: "ContractInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ContractInfo<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The code associated with a given account."}}, StorageFunctionMetadataV10{Name: "GasPrice", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The price of one unit of gas."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "update_schedule", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "schedule", Type: "Schedule"}}, Documentation: []Text{" Updates the schedule for metering contracts.", "", " The schedule must have a greater version than the stored schedule."}}, FunctionMetadataV4{Name: "put_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Gas>"}, FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Stores the given binary Wasm code into the chain's storage and returns its `codehash`.", " You can instantiate contracts only with stored code."}}, FunctionMetadataV4{Name: "call", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Gas>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."}}, FunctionMetadataV4{Name: "instantiate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Gas>"}, FunctionArgumentMetadata{Name: "code_hash", Type: "CodeHash<T>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.", "", " Instantiation is executed as follows:", "", " - The destination address is computed based on the sender and hash of the code.", " - The smart-contract account is created at the computed address.", " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned", "   after the execution is saved as the `code` of the account. That code will be invoked", "   upon any call received by this account.", " - The contract is initialized."}}, FunctionMetadataV4{Name: "claim_surcharge", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "aux_sender", Type: "Option<T::AccountId>"}}, Documentation: []Text{" Allows block producers to claim a small reward for evicting a contract. If a block producer", " fails to do so, a regular users will be allowed to claim the reward.", "", " If contract is not evicted as a result of this call, no actions are taken and", " the sender is not eligible for the reward."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer happened `from` to `to` with given `value` as part of a `call` or `instantiate`."}}, EventMetadataV4{Name: "Instantiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract deployed by address at the specified address."}}, EventMetadataV4{Name: "Evicted", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" Contract has been evicted and is now in tombstone state.", "", " # Params", "", " - `contract`: `AccountId`: The account ID of the evicted contract.", " - `tombstone`: `bool`: True if the evicted contract left behind a tombstone."}}, EventMetadataV4{Name: "Restored", Args: []Type{"AccountId", "AccountId", "Hash", "Balance", "bool"}, Documentation: []Text{" Restoration for a contract has been initiated.", "", " # Params", "", " - `donor`: `AccountId`: Account ID of the restoring contract", " - `dest`: `AccountId`: Account ID of the restored contract", " - `code_hash`: `Hash`: Code hash of the restored contract", " - `rent_allowance: `Balance`: Rent allowance of the restored contract", " - `success`: `bool`: True if the restoration was successful"}}, EventMetadataV4{Name: "CodeStored", Args: []Type{"Hash"}, Documentation: []Text{" Code with the specified hash has been stored."}}, EventMetadataV4{Name: "ScheduleUpdated", Args: []Type{"u32"}, Documentation: []Text{" Triggered when the current schedule is updated."}}, EventMetadataV4{Name: "Dispatched", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A call was dispatched from the given account. The bool signals whether it was", " successful execution or not."}}, EventMetadataV4{Name: "ContractExecution", Args: []Type{"AccountId", "Vec<u8>"}, Documentation: []Text{" An event deposited upon execution of a contract from the account."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "SignedClaimHandicap", Type: "T::BlockNumber", Value: Bytes{0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of block delay an extrinsic claim surcharge has.", "", " When claim surcharge is called by an extrinsic the rent is checked", " for current_block - delay"}}, ModuleConstantMetadataV6{Name: "TombstoneDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to generate a tombstone."}}, ModuleConstantMetadataV6{Name: "StorageSizeOffset", Type: "u32", Value: Bytes{0x8, 0x0, 0x0, 0x0}, Documentation: []Text{" Size of a contract at the time of instantiation. This is a simple way to ensure that", " empty contracts eventually gets deleted."}}, ModuleConstantMetadataV6{Name: "RentByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Price of a byte of storage per one block interval. Should be greater than 0."}}, ModuleConstantMetadataV6{Name: "RentDepositOffset", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0x8a, 0x5d, 0x78, 0x45, 0x63, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of funds a contract should deposit in order to offset", " the cost of one byte.", "", " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,", " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.", " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,", " then it would pay 500 BU/day."}}, ModuleConstantMetadataV6{Name: "SurchargeReward", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xa1, 0xa7, 0x6b, 0x4a, 0x35, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reward that is received by the party whose touch has led", " to removal of a contract."}}, ModuleConstantMetadataV6{Name: "TransactionBaseFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, ModuleConstantMetadataV6{Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}, ModuleConstantMetadataV6{Name: "ContractFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to instantiate a contract instance. A reasonable default value", " is 21."}}, ModuleConstantMetadataV6{Name: "CallBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for calling into a contract. A reasonable default", " value is 135."}}, ModuleConstantMetadataV6{Name: "InstantiateBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for instantiating a contract. A reasonable default value", " is 175."}}, ModuleConstantMetadataV6{Name: "MaxDepth", Type: "u32", Value: Bytes{0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum nesting level of a call/instantiate stack. A reasonable default", " value is 100."}}, ModuleConstantMetadataV6{Name: "MaxValueSize", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" The maximum size of a storage value in bytes. A reasonable default is 16 KiB."}}, ModuleConstantMetadataV6{Name: "BlockGasLimit", Type: "Gas", Value: Bytes{0x80, 0x96, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of gas that could be expended per block. A reasonable", " default value is 10_000_000."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidScheduleVersion", Documentation: []Text{" A new schedule must have a greater version than the current one."}}, ErrorMetadataV8{Name: "InvalidSurchargeClaim", Documentation: []Text{" An origin must be signed or inherent and auxiliary sender only provided on inherent."}}, ErrorMetadataV8{Name: "InvalidSourceContract", Documentation: []Text{" Cannot restore from nonexisting or tombstone contract."}}, ErrorMetadataV8{Name: "InvalidDestinationContract", Documentation: []Text{" Cannot restore to nonexisting or alive contract."}}, ErrorMetadataV8{Name: "InvalidTombstone", Documentation: []Text{" Tombstones don't match."}}, ErrorMetadataV8{Name: "InvalidContractOrigin", Documentation: []Text{" An origin TrieId written in the current block."}}}}, ModuleMetadataV10{Name: "Sudo", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Sudo", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Key", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The `AccountId` of the sudo key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "sudo", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}, FunctionMetadataV4{Name: "set_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, FunctionMetadataV4{Name: "sudo_as", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Signed` origin from", " a given account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Sudid", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}, EventMetadataV4{Name: "KeyChanged", Args: []Type{"AccountId"}, Documentation: []Text{" The sudoer just switched identity; the old key is supplied."}}, EventMetadataV4{Name: "SudoAsDone", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "RequireSudo", Documentation: []Text{" Sender must be the Sudo account"}}}}, ModuleMetadataV10{Name: "ImOnline", HasStorage: true, Storage: StorageMetadataV10{Prefix: "ImOnline", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "HeartbeatAfter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block number after which it's ok to send heartbeats in current session.", "", " At the beginning of each session we set this to a value that should", " fall roughly in the middle of the session duration.", " The idea is to first wait for the validators to produce a block", " in the current session, so that the heartbeat later on will not be necessary."}}, StorageFunctionMetadataV10{Name: "Keys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AuthorityId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of keys that may issue a heartbeat."}}, StorageFunctionMetadataV10{Name: "ReceivedHeartbeats", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "SessionIndex", Key2: "AuthIndex", Value: "Vec<u8>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" For each session index, we keep a mapping of `AuthIndex`", " to `offchain::OpaqueNetworkState`."}}, StorageFunctionMetadataV10{Name: "AuthoredBlocks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "SessionIndex", Key2: "T::ValidatorId", Value: "u32", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" For each session index, we keep a mapping of `T::ValidatorId` to the", " number of blocks authored by the given authority."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "heartbeat", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "heartbeat", Type: "Heartbeat<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "_signature", Type: "<T::AuthorityId as RuntimeAppPublic>::Signature"}}, Documentation: []Text(nil)}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "HeartbeatReceived", Args: []Type{"AuthorityId"}, Documentation: []Text{" A new heartbeat was received from `AuthorityId`"}}, EventMetadataV4{Name: "AllGood", Args: []Type(nil), Documentation: []Text{" At the end of the session, no offence was committed."}}, EventMetadataV4{Name: "SomeOffline", Args: []Type{"Vec<IdentificationTuple>"}, Documentation: []Text{" At the end of the session, at least once validator was found to be offline."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidKey", Documentation: []Text{" Non existent public key."}}, ErrorMetadataV8{Name: "DuplicatedHeartbeat", Documentation: []Text{" Duplicated heartbeat."}}}}, ModuleMetadataV10{Name: "AuthorityDiscovery", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Offences", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Offences", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Reports", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReportIdOf<T>", Value: "OffenceDetails<T::AccountId, T::IdentificationTuple>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The primary structure that holds all offence records keyed by report identifiers."}}, StorageFunctionMetadataV10{Name: "ConcurrentReportsIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "Kind", Key2: "OpaqueTimeSlot", Value: "Vec<ReportIdOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A vector of reports of the same kind that happened at the same time slot."}}, StorageFunctionMetadataV10{Name: "ReportsByKindIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "Kind", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Enumerates all reports of a kind along with the time they happened.", "", " All reports are sorted by the time of offence.", "", " Note that the actual type of this mapping is `Vec<u8>`, this is because values of", " different types are not supported at the moment so we are doing the manual serialization."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Offence", Args: []Type{"Kind", "OpaqueTimeSlot"}, Documentation: []Text{" There is an offence reported of the given `kind` happened at the `session_index` and", " (kind-specific) time slot. This event is not deposited for duplicate slashes."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: StorageMetadataV10{Prefix: "RandomnessCollectiveFlip", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "RandomMaterial", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Identity", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Sudo", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "IdentityOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Registration<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information that is pertinent to identify the entity behind an account."}}, StorageFunctionMetadataV10{Name: "SuperOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(T::AccountId, Data)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The super-identity of an alternative \"sub\" identity together with its name, within that", " context. If the account is not some other account's sub-identity, then just `None`."}}, StorageFunctionMetadataV10{Name: "SubsOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Alternative \"sub\" identities of this account.", "", " The first item is the deposit, the second is a vector of the accounts."}}, StorageFunctionMetadataV10{Name: "Registrars", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Option<RegistrarInfo<BalanceOf<T>, T::AccountId>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of registrars. Not expected to get very big as can only be added through a", " special origin (likely a council motion).", "", " The index into this can be cast to `RegistrarIndex` to get a valid value."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_registrar", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Add a registrar to the system.", "", " The dispatch origin for this call must be `RegistrarOrigin` or `Root`.", "", " - `account`: the account of the registrar.", "", " Emits `RegistrarAdded` if successful.", "", " # <weight>", " - `O(R)` where `R` registrar-count (governance-bounded).", " - One storage mutation (codec `O(R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "info", Type: "IdentityInfo"}}, Documentation: []Text{" Set an account's identity information and reserve the appropriate deposit.", "", " If the account already has identity information, the deposit is taken as part payment", " for the new deposit.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " - `info`: The identity information.", "", " Emits `IdentitySet` if successful.", "", " # <weight>", " - `O(X + X' + R)` where `X` additional-field-count (deposit-bounded and code-bounded).", " - At most two balance operations.", " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_subs", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "subs", Type: "Vec<(T::AccountId, Data)>"}}, Documentation: []Text{" Set the sub-accounts of the sender.", "", " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned", " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " - `subs`: The identity's sub-accounts.", "", " # <weight>", " - `O(S)` where `S` subs-count (hard- and deposit-bounded).", " - At most two balance operations.", " - At most O(2 * S + 1) storage mutations; codec complexity `O(1 * S + S * 1)`);", "   one storage-exists.", " # </weight>"}}, FunctionMetadataV4{Name: "clear_identity", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear an account's identity info and all sub-account and return all deposits.", "", " Payment: All reserved balances on the account are returned.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " Emits `IdentityCleared` if successful.", "", " # <weight>", " - `O(R + S + X)`.", " - One balance-reserve operation.", " - `S + 2` storage deletions.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "request_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "max_fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Request a judgement from a registrar.", "", " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement", " given.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is requested.", " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:", "", " ```nocompile", " Self::registrars(reg_index).unwrap().fee", " ```", "", " Emits `JudgementRequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_request", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "RegistrarIndex"}}, Documentation: []Text{" Cancel a previous request.", "", " Payment: A previously reserved deposit is returned on success.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is no longer requested.", "", " Emits `JudgementUnrequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - One storage mutation `O(R + X)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_fee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Set the fee required for a judgement to be requested from a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fee`: the new fee.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " # </weight>"}}, FunctionMetadataV4{Name: "set_account_id", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Change the account associated with a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `new`: the new account ID.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " # </weight>"}}, FunctionMetadataV4{Name: "set_fields", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fields", Type: "IdentityFields"}}, Documentation: []Text{" Set the field information for a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fields`: the fields that the registrar concerns themselves with.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " # </weight>"}}, FunctionMetadataV4{Name: "provide_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement<BalanceOf<T>>"}}, Documentation: []Text{" Provide a judgement for an account's identity.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `reg_index`.", "", " - `reg_index`: the index of the registrar whose judgement is being made.", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.", "", " Emits `JudgementGiven` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-transfer operation.", " - Up to one account-lookup operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "kill_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove an account's identity and sub-account information and slash the deposits.", "", " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by", " `Slash`. Verification request deposits are not returned; they should be cancelled", " manually using `cancel_request`.", "", " The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.", "", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", "", " Emits `IdentityKilled` if successful.", "", " # <weight>", " - `O(R + S + X)`.", " - One balance-reserve operation.", " - `S + 2` storage mutations.", " - One event.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IdentitySet", Args: []Type{"AccountId"}, Documentation: []Text{" A name was set or reset (which will remove all judgements)."}}, EventMetadataV4{Name: "IdentityCleared", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was cleared, and the given balance returned."}}, EventMetadataV4{Name: "IdentityKilled", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was removed and the given balance slashed."}}, EventMetadataV4{Name: "JudgementRequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was asked from a registrar."}}, EventMetadataV4{Name: "JudgementUnrequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement request was retracted."}}, EventMetadataV4{Name: "JudgementGiven", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was given by a registrar."}}, EventMetadataV4{Name: "RegistrarAdded", Args: []Type{"RegistrarIndex"}, Documentation: []Text{" A registrar was added."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "TooManySubAccounts", Documentation: []Text{" Too many subs-accounts."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Account isn't found."}}, ErrorMetadataV8{Name: "NotNamed", Documentation: []Text{" Account isn't named."}}, ErrorMetadataV8{Name: "EmptyIndex", Documentation: []Text{" Empty index."}}, ErrorMetadataV8{Name: "FeeChanged", Documentation: []Text{" Fee is changed."}}, ErrorMetadataV8{Name: "NoIdentity", Documentation: []Text{" No identity found."}}, ErrorMetadataV8{Name: "StickyJudgement", Documentation: []Text{" Sticky judgement."}}, ErrorMetadataV8{Name: "JudgementGiven", Documentation: []Text{" Judgement given."}}, ErrorMetadataV8{Name: "InvalidJudgement", Documentation: []Text{" Invalid judgement."}}, ErrorMetadataV8{Name: "InvalidIndex", Documentation: []Text{" The index is invalid."}}, ErrorMetadataV8{Name: "InvalidTarget", Documentation: []Text{" The target is invalid."}}, ErrorMetadataV8{Name: "TooManyFields", Documentation: []Text{" Too many additional fields."}}}}, ModuleMetadataV10{Name: "Society", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Society", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Founder", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The first member."}}, StorageFunctionMetadataV10{Name: "Rules", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A hash of the rules of this society concerning membership. Can only be set once and", " only by the founder."}}, StorageFunctionMetadataV10{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of candidates; bidders that are attempting to become members."}}, StorageFunctionMetadataV10{Name: "SuspendedCandidates", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(BalanceOf<T, I>, BidKind<T::AccountId, BalanceOf<T, I>>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended candidates."}}, StorageFunctionMetadataV10{Name: "Pot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "BalanceOf<T, I>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Amount of our account balance that is specifically for the next round's bid(s)."}}, StorageFunctionMetadataV10{Name: "Head", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The most primary from the most recently approved members."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of members, ordered."}}, StorageFunctionMetadataV10{Name: "SuspendedMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended members."}}, StorageFunctionMetadataV10{Name: "Bids", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current bids, stored ordered by the value of the bid."}}, StorageFunctionMetadataV10{Name: "Vouching", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "VouchingStatus", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Members currently vouching or banned from vouching again"}}, StorageFunctionMetadataV10{Name: "Payouts", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<(T::BlockNumber, BalanceOf<T, I>)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending payouts; ordered by block number, with the amount that should be paid out."}}, StorageFunctionMetadataV10{Name: "Strikes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "StrikeCount", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ongoing number of losing votes cast by the member."}}, StorageFunctionMetadataV10{Name: "Votes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "Vote", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Double map from Candidate -> Voter -> (Maybe) Vote."}}, StorageFunctionMetadataV10{Name: "Defender", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The defending member currently being challenged."}}, StorageFunctionMetadataV10{Name: "DefenderVotes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key: "T::AccountId", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes for the defender."}}, StorageFunctionMetadataV10{Name: "MaxMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The max number of members for the society at one time."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" A user outside of the society can make a bid for entry.", "", " Payment: `CandidateDeposit` will be reserved for making a bid. It is returned", " when the bid becomes a member, or if the bid calls `unbid`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `value`: A one time payment the bid would like to receive when joining the society.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)", " - Storage Reads:", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " \t- One storage read to retrieve all members. O(M)", " - Storage Writes:", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for new bid.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unbid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" A bidder can remove their bid for entry into society.", " By doing so, they will have their candidate deposit returned or", " they will unvouch their voucher.", "", " Payment: The bid deposit is unreserved if the user made a bid.", "", " The dispatch origin for this call must be _Signed_ and a bidder.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who wants to unbid.", "", " # <weight>", " Key: B (len of bids), X (balance unreserve)", " - One storage read and write to retrieve and update the bids. O(B)", " - Either one unreserve balance action O(X) or one vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}, FunctionArgumentMetadata{Name: "tip", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" As a member, vouch for someone to join society by placing a bid on their behalf.", "", " There is no deposit required to vouch for a new bid, but a member can only vouch for", " one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by", " the suspension judgement origin, the member will be banned from vouching again.", "", " As a vouching member, you can claim a tip if the candidate is accepted. This tip will", " be paid as a portion of the reward the member will receive for joining the society.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `who`: The user who you would like to vouch for.", " - `value`: The total reward to be paid between you and the candidate if they become", " a member in the society.", " - `tip`: Your cut of the total `value` payout when the candidate is inducted into", " the society. Tips larger than `value` will be saturated upon payout.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members)", " - Storage Reads:", " \t- One storage read to retrieve all members. O(M)", " \t- One storage read to check member is not already vouching. O(1)", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " - Storage Writes:", " \t- One storage write to insert vouching status to the member. O(1)", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(log M) search to check sender is a member.", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for vouch.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unvouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" As a vouching member, unvouch a bid. This only works while vouched user is", " only a bidder (and not a candidate).", "", " The dispatch origin for this call must be _Signed_ and a vouching member.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who should be unvouched.", "", " # <weight>", " Key: B (len of bids)", " - One storage read O(1) to check the signer is a vouching member.", " - One storage mutate to retrieve and update the bids. O(B)", " - One vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B)", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "candidate", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on a candidate.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `candidate`: The candidate that the member would like to bid on.", " - `approve`: A boolean which says if the candidate should be", "              approved (`true`) or rejected (`false`).", "", " # <weight>", " Key: C (len of candidates), M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One account lookup.", " - One storage read O(C) and O(C) search to check that user is a candidate.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM + C)", " # </weight>"}}, FunctionMetadataV4{Name: "defender_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on the defender.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `approve`: A boolean which says if the candidate should be", " approved (`true`) or rejected (`false`).", "", " # <weight>", " - Key: M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM)", " # </weight>"}}, FunctionMetadataV4{Name: "payout", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Transfer the first matured payout for the sender and remove it from the records.", "", " NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.", "", " Payment: The member will receive a payment equal to their first matured", " payout to their free balance.", "", " The dispatch origin for this call must be _Signed_ and a member with", " payouts remaining.", "", " # <weight>", " Key: M (len of members), P (number of payouts for a particular member)", " - One storage read O(M) and O(log M) search to check signer is a member.", " - One storage read O(P) to get all payouts for a member.", " - One storage read O(1) to get the current block number.", " - One currency transfer call. O(X)", " - One storage write or removal to update the member's payouts. O(P)", "", " Total Complexity: O(M + logM + P + X)", " # </weight>"}}, FunctionMetadataV4{Name: "found", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "founder", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "max_members", Type: "u32"}, FunctionArgumentMetadata{Name: "rules", Type: "Vec<u8>"}}, Documentation: []Text{" Found the society.", "", " This is done as a discrete action in order to allow for the", " module to be included into a running chain and can only be done once.", "", " The dispatch origin for this call must be from the _FounderSetOrigin_.", "", " Parameters:", " - `founder` - The first member and head of the newly founded society.", " - `max_members` - The initial max number of members for the society.", " - `rules` - The rules of this society concerning membership.", "", " # <weight>", " - Two storage mutates to set `Head` and `Founder`. O(1)", " - One storage write to add the first member to society. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "unfound", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Annul the founding of the society.", "", " The dispatch origin for this call must be Signed, and the signing account must be both", " the `Founder` and the `Head`. This implies that it may only be done when there is one", " member.", "", " # <weight>", " - Two storage reads O(1).", " - Four storage removals O(1).", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "forgive", Type: "bool"}}, Documentation: []Text{" Allow suspension judgement origin to make judgement on a suspended member.", "", " If a suspended member is forgiven, we simply add them back as a member, not affecting", " any of the existing storage items for that member.", "", " If a suspended member is rejected, remove all associated storage items, including", " their payouts, and remove any vouched bids they currently have.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended member to be judged.", " - `forgive` - A boolean representing whether the suspension judgement origin", "               forgives (`true`) or rejects (`false`) a suspended member.", "", " # <weight>", " Key: B (len of bids), M (len of members)", " - One storage read to check `who` is a suspended member. O(1)", " - Up to one storage write O(M) with O(log M) binary search to add a member back to society.", " - Up to 3 storage removals O(1) to clean up a removed member.", " - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal. O(1)", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_candidate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement"}}, Documentation: []Text{" Allow suspended judgement origin to make judgement on a suspended candidate.", "", " If the judgement is `Approve`, we add them to society as a member with the appropriate", " payment for joining society.", "", " If the judgement is `Reject`, we either slash the deposit of the bid, giving it back", " to the society treasury, or we ban the voucher from vouching again.", "", " If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go", " through the induction process again.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended candidate to be judged.", " - `judgement` - `Approve`, `Reject`, or `Rebid`.", "", " # <weight>", " Key: B (len of bids), M (len of members), X (balance action)", " - One storage read to check `who` is a suspended candidate.", " - One storage removal of the suspended candidate.", " - Approve Logic", " \t- One storage read to get the available pot to pay users with. O(1)", " \t- One storage write to update the available pot. O(1)", " \t- One storage read to get the current block number. O(1)", " \t- One storage read to get all members. O(M)", " \t- Up to one unreserve currency action.", " \t- Up to two new storage writes to payouts.", " \t- Up to one storage write with O(log M) binary search to add a member to society.", " - Reject Logic", " \t- Up to one repatriate reserved currency action. O(X)", " \t- Up to one storage write to ban the vouching member from vouching again.", " - Rebid Logic", " \t- Storage mutate with O(log B) binary search to place the user back into bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal.", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "set_max_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max", Type: "u32"}}, Documentation: []Text{" Allows root origin to change the maximum number of members in society.", " Max membership count must be greater than 1.", "", " The dispatch origin for this call must be from _ROOT_.", "", " Parameters:", " - `max` - The maximum number of members for the society.", "", " # <weight>", " - One storage write to update the max. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Founded", Args: []Type{"AccountId"}, Documentation: []Text{" The society is founded by the given identity."}}, EventMetadataV4{Name: "Bid", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A membership bid just happened. The given account is the candidate's ID and their offer", " is the second."}}, EventMetadataV4{Name: "Vouch", Args: []Type{"AccountId", "Balance", "AccountId"}, Documentation: []Text{" A membership bid just happened by vouching. The given account is the candidate's ID and", " their offer is the second. The vouching party is the third."}}, EventMetadataV4{Name: "AutoUnbid", Args: []Type{"AccountId"}, Documentation: []Text{" A candidate was dropped (due to an excess of bids in the system)."}}, EventMetadataV4{Name: "Unbid", Args: []Type{"AccountId"}, Documentation: []Text{" A candidate was dropped (by their request)."}}, EventMetadataV4{Name: "Unvouch", Args: []Type{"AccountId"}, Documentation: []Text{" A candidate was dropped (by request of who vouched for them)."}}, EventMetadataV4{Name: "Inducted", Args: []Type{"AccountId", "Vec<AccountId>"}, Documentation: []Text{" A group of candidates have been inducted. The batch's primary is the first value, the", " batch in full is the second."}}, EventMetadataV4{Name: "SuspendedMemberJudgement", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A suspended member has been judged"}}, EventMetadataV4{Name: "CandidateSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A candidate has been suspended"}}, EventMetadataV4{Name: "MemberSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A member has been suspended"}}, EventMetadataV4{Name: "Challenged", Args: []Type{"AccountId"}, Documentation: []Text{" A member has been challenged"}}, EventMetadataV4{Name: "Vote", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A vote has been placed (candidate, voter, vote)"}}, EventMetadataV4{Name: "DefenderVote", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A vote has been placed for a defending member (voter, vote)"}}, EventMetadataV4{Name: "NewMaxMembers", Args: []Type{"u32"}, Documentation: []Text{" A new max member count has been set"}}, EventMetadataV4{Name: "Unfounded", Args: []Type{"AccountId"}, Documentation: []Text{" Society is unfounded."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "CandidateDeposit", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount of a deposit required for a bid to be made."}}, ModuleConstantMetadataV6{Name: "WrongSideDeduction", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of the unpaid reward that gets deducted in the case that either a skeptic", " doesn't vote or someone votes in the wrong way."}}, ModuleConstantMetadataV6{Name: "MaxStrikes", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of times a member may vote the wrong way (or not at all, when they are a skeptic)", " before they become suspended."}}, ModuleConstantMetadataV6{Name: "PeriodSpend", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x0, 0xc5, 0x2e, 0xbc, 0xa2, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of incentive paid within each period. Doesn't include VoterTip."}}, ModuleConstantMetadataV6{Name: "RotationPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x77, 0x1, 0x0}, Documentation: []Text{" The number of blocks between candidate/membership rotation periods."}}, ModuleConstantMetadataV6{Name: "ChallengePeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text{" The number of blocks between membership challenges."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "BadPosition", Documentation: []Text{" An incorrect position was provided."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" User is not a member."}}, ErrorMetadataV8{Name: "AlreadyMember", Documentation: []Text{" User is already a member."}}, ErrorMetadataV8{Name: "Suspended", Documentation: []Text{" User is suspended."}}, ErrorMetadataV8{Name: "NotSuspended", Documentation: []Text{" User is not suspended."}}, ErrorMetadataV8{Name: "NoPayout", Documentation: []Text{" Nothing to payout."}}, ErrorMetadataV8{Name: "AlreadyFounded", Documentation: []Text{" Society already founded."}}, ErrorMetadataV8{Name: "InsufficientPot", Documentation: []Text{" Not enough in pot to accept candidate."}}, ErrorMetadataV8{Name: "AlreadyVouching", Documentation: []Text{" Member is already vouching or banned from vouching again."}}, ErrorMetadataV8{Name: "NotVouching", Documentation: []Text{" Member is not vouching."}}, ErrorMetadataV8{Name: "Head", Documentation: []Text{" Cannot remove the head of the chain."}}, ErrorMetadataV8{Name: "Founder", Documentation: []Text{" Cannot remove the founder."}}, ErrorMetadataV8{Name: "AlreadyBid", Documentation: []Text{" User has already made a bid."}}, ErrorMetadataV8{Name: "AlreadyCandidate", Documentation: []Text{" User is already a candidate."}}, ErrorMetadataV8{Name: "NotCandidate", Documentation: []Text{" User is not a candidate."}}, ErrorMetadataV8{Name: "MaxMembers", Documentation: []Text{" Too many members in the society."}}, ErrorMetadataV8{Name: "NotFounder", Documentation: []Text{" The caller is not the founder."}}, ErrorMetadataV8{Name: "NotHead", Documentation: []Text{" The caller is not the head."}}}}, ModuleMetadataV10{Name: "Recovery", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Recovery", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Recoverable", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "RecoveryConfig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of recoverable accounts and their recovery configuration."}}, StorageFunctionMetadataV10{Name: "ActiveRecoveries", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "ActiveRecovery<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Active recovery attempts.", "", " First account is the account to be recovered, and the second account", " is the user trying to recover the account."}}, StorageFunctionMetadataV10{Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The list of allowed proxy accounts.", "", " Map from the user who can access it to the recovered account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "as_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Send a call through a recovered account.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you want to make a call on-behalf-of.", " - `call`: The call you want to make with the recovered account.", "", " # <weight>", " - The weight of the `call` + 10,000.", " - One storage lookup to check account is recovered by `who`. O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "set_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow ROOT to bypass the recovery process and set an a rescuer account", " for a lost account directly.", "", " The dispatch origin for this call must be _ROOT_.", "", " Parameters:", " - `lost`: The \"lost account\" to be recovered.", " - `rescuer`: The \"rescuer account\" which can call as the lost account.", "", " # <weight>", " - One storage write O(1)", " - One event", " # </weight>"}}, FunctionMetadataV4{Name: "create_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "friends", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "delay_period", Type: "T::BlockNumber"}}, Documentation: []Text{" Create a recovery configuration for your account. This makes your account recoverable.", "", " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance", " will be reserved for storing the recovery configuration. This deposit is returned", " in full when the user calls `remove_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `friends`: A list of friends you trust to vouch for recovery attempts.", "   Should be ordered and contain no duplicate values.", " - `threshold`: The number of friends that must vouch for a recovery attempt", "   before the account can be recovered. Should be less than or equal to", "   the length of the list of friends.", " - `delay_period`: The number of blocks after a recovery attempt is initialized", "   that needs to pass before the account can be recovered.", "", " # <weight>", " - Key: F (len of friends)", " - One storage read to check that account is not already recoverable. O(1).", " - A check that the friends list is sorted and unique. O(F)", " - One currency reserve operation. O(X)", " - One storage write. O(1). Codec O(F).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "initiate_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Initiate the process for recovering a recoverable account.", "", " Payment: `RecoveryDeposit` balance will be reserved for initiating the", " recovery process. This deposit will always be repatriated to the account", " trying to be recovered. See `close_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `account`: The lost account that you want to recover. This account", "   needs to be recoverable (i.e. have a recovery configuration).", "", " # <weight>", " - One storage read to check that account is recoverable. O(F)", " - One storage read to check that this recovery process hasn't already started. O(1)", " - One currency reserve operation. O(X)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow a \"friend\" of a recoverable account to vouch for an active recovery", " process for that account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"friend\"", " for the recoverable account.", "", " Parameters:", " - `lost`: The lost account that you want to recover.", " - `rescuer`: The account trying to rescue the lost account that you", "   want to vouch for.", "", " The combination of these two parameters must point to an active recovery", " process.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One binary search to confirm caller is a friend. O(logF)", " - One binary search to confirm caller has not already vouched. O(logV)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + logF + V + logV)", " # </weight>"}}, FunctionMetadataV4{Name: "claim_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Allow a successful rescuer to claim their recovered account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"", " who has successfully completed the account recovery process: collected", " `threshold` or more vouches, waited `delay_period` blocks since initiation.", "", " Parameters:", " - `account`: The lost account that you want to claim has been successfully", "   recovered by you.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + V)", " # </weight>"}}, FunctionMetadataV4{Name: "close_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" As the controller of a recoverable account, close an active recovery", " process for your account.", "", " Payment: By calling this function, the recoverable account will receive", " the recovery deposit `RecoveryDeposit` placed by the rescuer.", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account with an active recovery process for it.", "", " Parameters:", " - `rescuer`: The account trying to rescue this recoverable account.", "", " # <weight>", " Key: V (len of vouching friends)", " - One storage read/remove to get the active recovery process. O(1), Codec O(V)", " - One balance call to repatriate reserved. O(X)", " - One event.", "", " Total Complexity: O(V + X)", " # </weight>"}}, FunctionMetadataV4{Name: "remove_recovery", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the recovery process for your account. Recovered accounts are still accessible.", "", " NOTE: The user must make sure to call `close_recovery` on all active", " recovery attempts before calling this function else it will fail.", "", " Payment: By calling this function the recoverable account will unreserve", " their recovery configuration deposit.", " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account (i.e. has a recovery configuration).", "", " # <weight>", " Key: F (len of friends)", " - One storage read to get the prefix iterator for active recoveries. O(1)", " - One storage read/remove to get the recovery configuration. O(1), Codec O(F)", " - One balance call to unreserved. O(X)", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Cancel the ability to use `as_recovered` for `account`.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you are able to call on-behalf-of.", "", " # <weight>", " - One storage mutation to check account is recovered by `who`. O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "RecoveryCreated", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been set up for an account"}}, EventMetadataV4{Name: "RecoveryInitiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process has been initiated for account_1 by account_2"}}, EventMetadataV4{Name: "RecoveryVouched", Args: []Type{"AccountId", "AccountId", "AccountId"}, Documentation: []Text{" A recovery process for account_1 by account_2 has been vouched for by account_3"}}, EventMetadataV4{Name: "RecoveryClosed", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process for account_1 by account_2 has been closed"}}, EventMetadataV4{Name: "AccountRecovered", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Account_1 has been successfully recovered by account_2"}}, EventMetadataV4{Name: "RecoveryRemoved", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been removed for an account"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotAllowed", Documentation: []Text{" User is not allowed to make a call on behalf of this account"}}, ErrorMetadataV8{Name: "ZeroThreshold", Documentation: []Text{" Threshold must be greater than zero"}}, ErrorMetadataV8{Name: "NotEnoughFriends", Documentation: []Text{" Friends list must be greater than zero and threshold"}}, ErrorMetadataV8{Name: "MaxFriends", Documentation: []Text{" Friends list must be less than max friends"}}, ErrorMetadataV8{Name: "NotSorted", Documentation: []Text{" Friends list must be sorted and free of duplicates"}}, ErrorMetadataV8{Name: "NotRecoverable", Documentation: []Text{" This account is not set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyRecoverable", Documentation: []Text{" This account is already set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyStarted", Documentation: []Text{" A recovery process has already started for this account"}}, ErrorMetadataV8{Name: "NotStarted", Documentation: []Text{" A recovery process has not started for this rescuer"}}, ErrorMetadataV8{Name: "NotFriend", Documentation: []Text{" This account is not a friend who can vouch"}}, ErrorMetadataV8{Name: "DelayPeriod", Documentation: []Text{" The friend must wait until the delay period to vouch for this recovery"}}, ErrorMetadataV8{Name: "AlreadyVouched", Documentation: []Text{" This user has already vouched for this recovery"}}, ErrorMetadataV8{Name: "Threshold", Documentation: []Text{" The threshold for recovering this account has not been met"}}, ErrorMetadataV8{Name: "StillActive", Documentation: []Text{" There are still active recovery attempts that need to be closed"}}, ErrorMetadataV8{Name: "Overflow", Documentation: []Text{" There was an overflow in a calculation"}}, ErrorMetadataV8{Name: "AlreadyProxy", Documentation: []Text{" This account is already set up for recovery"}}}}, ModuleMetadataV10{Name: "Vesting", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Vesting", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Vesting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: true, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "VestingInfo<BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information regarding the vesting of a given account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vest", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Unlock any vested funds of the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must have funds still", " locked under this module.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - One balance-lock operation.", " - One storage read (codec `O(1)`) and up to one removal.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "vest_other", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Unlock any vested funds of a `target` account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `target`: The account whose vested funds should be unlocked. Must have funds still", " locked under this module.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - Up to one account lookup.", " - One balance-lock operation.", " - One storage read (codec `O(1)`) and up to one removal.", " - One event.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "VestingUpdated", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The amount vested has been updated. This could indicate more funds are available. The", " balance given is the amount which is left unvested (and thus locked)."}}, EventMetadataV4{Name: "VestingCompleted", Args: []Type{"AccountId"}, Documentation: []Text{" An account (given) has become fully vested. No further vesting can happen."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotVesting", Documentation: []Text{" The account given is not vesting."}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" An existing vesting schedule already exists for this account that cannot be clobbered."}}}}}}, Extrinsic: ExtrinsicV11{Version: 0x4, SignedExtensions: []string{"CheckVersion", "CheckGenesis", "CheckEra", "CheckNonce", "CheckWeight", "ChargeTransactionPayment", "CheckBlockGasLimit"}}}}
